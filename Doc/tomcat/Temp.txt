<-----------------------------Tomcat流程------------------>
Digest解析
    ----->StandardServer初始化
    ----->StandardService初始化
    ----->Connector带参数初始化(HTTP/1.1)
         ------------->Http11NioProtocol实例化
                     ------------> super(new NioEndpoint());
        ？？初始化两次

    ----->StandardEngine初始化
          添加EngineConfig作为listerner

    ----->StandardHost初始化
          添加HostConfig作为listerner

    ----->调用StandardEngine的addChild方法StandardHost
    ----->调用StandardServer的addService的
    
getServer().init();
    ------>StnadardServer init
            ----->engine.init()
                ----->ContainerBase.init
                ```
                    BlockingQueue<Runnable> startStopQueue = new LinkedBlockingQueue<>();
                    startStopExecutor = new ThreadPoolExecutor(
                    getStartStopThreadsInternal(),
                    getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,
                    startStopQueue,
                    new StartStopThreadFactory(getName() + "-startStop-"));
                    startStopExecutor.allowCoreThreadTimeOut(true);
                    super.initInternal();
                ```
            ----->executor.init()
            ----->mapperListener.init()
            ----->connector.init()

bootStrip.Start()
    ------>StnadardServer start
            ----->engine.start()
                ----->ContainerBase.start()
                    ----->Realm.start()
                    ----->子容器(Standardhost)线程启动
                            Container children[] = findChildren();
                            List<Future<Void>> results = new ArrayList<>();
                            for (int i = 0; i < children.length; i++) {
                                results.add(startStopExecutor.submit(new StartChild(children[i])));
                            }
                        子容器需要先调用init再调用start
                    ----> 子容器在启动后会调用setState(LifecycleState.STARTING);
                      ------>触发了hostconfig的start方法
                        ------>deployApps，分为3种类型的部署
                                 在加载xml的过程中会解析xml生成StandContext类，
                                 调用StandardHost的addchild方法
                                    ---->调用StandardContext的start方法
                                        ----->setResources(new StandardRoot(this));
                                        ----->resourcesStart

                                deployDescriptors
                                        
                                deployWARs
                                        、C:\workspace\Tomcat9\webapps、及下面的文件夹
                                deployDirectories

                               
            ----->executor.start()
            ----->mapperListener.start()
            ----->connector.start()

    ----->所有继承ContainBase的类都会通过线程池FtureTask启动
    ----->StandardHost的StartInternal方法，fireEvent启动，init、start
    ----->StandardContext的start方法： setResources(new StandardRoot(this));
	
<---------------------------------punch hole------------------------------>
预备知识

1、内网访问外网时，路由器/防火墙会把内网地址(源IP端口)包装成自己的IP+随机端口
2、路由器/防火墙在包装Ip和端口时，不管目的IP端口是什么，只要来源ip端口一致则包装成成相同的IP端口
   eg:
   Host1通过本地端口12345访问 XXXXXX:4567,出来的源IP端口是   ：1.1.1.1:5678
则 Host1通过本地端口12345访问 YYYYYY:6789,出来的源IP端口也会是：1.1.1.1:5678


punch hole 程序分为两部分：服务端，客户端
流程如下：

1、服务端开启主要监听端口 30000
2、客户端A、B各自通过端口12345访问服务端30000
   1.1.1.123:12345--->1.1.1.1:11111---->XXXX:30000
   2.2.2.456:12345--->2.2.2.2:22222—--->XXXX:30000
3、客户端A告诉服务端端我要连接客户端B(2.2.2.2:22222),即1.1.1.123:12345---->2.2.2.2:22222
    1)1.1.123:12345被包装成1.1.1.1:11111----2.2.2.2:22222
    2)2.2.2.2机器根本不知道转给谁，丢弃，但是客户端A的防火墙据此保留了一些信息，即
       即：2.2.2.2:22222---->1.1.1.1:11111--->1.1.123:12345
4、客户端A告诉服务端：让客户端B用端口12345连接
HostA:1111-------->RouteA:1.1.1.1:9676------------>Server:5555<-------------------RouteB:2.2.2.2:6573<---------------HostB:2222
1、A:1111--->2.2.2.2:6573

UserA :1.1.1.11:1234
RouteA:1.1.1.1:4321
UserB :2.2.2.22:5678
RouteB:2.2.2.2：8765
Server:3.3.3.3:30000

1、UserA登录Server，(此时Server检测到UserA的Ip端口是RouteA)
    1)Server通知UserA，当前所有在线终端
    2)Serer通知其他在线终端，UserA在线

2、UserB同步骤1
3、PunchHole（A--->B)
   1)UserA向Server请求PunchHole UserB
     1.1)Server通知UserB，UserA想PunchHole
     1.2)UserB接受到Server，UserA想PunchHole，UserB-->UserA，此时会失败，因为UserB发送给RouteA，RouteA不知道转给谁。

   2)UserA--->UserB发送连接测试