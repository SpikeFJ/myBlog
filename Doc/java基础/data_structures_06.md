# 一. 归并排序

原本归并排序是在 递归 这一章介绍的，但是讲解快速排序时候使用到了归并，所以调整下，这里先介绍下归并排序。

## 1. 归并算法
归并算法的中心是合并两个已经有序的数组，生成第三个数组。

示意图如下：

![归并算法](../../Resource/data_structures_06_1.png)

代码如下：
```java

    void mergeSort() {
        int[] a = {23, 47, 81, 95};
        int[] b = {7, 14, 39, 55, 62, 74};

        int[] c = new int[a.length + b.length];

        int aIndex = 0;
        int bIndex = 0;
        int cIndex = 0;

        while (aIndex < a.length - 1 && bIndex < b.length - 1) {
            if (a[aIndex] < b[bIndex]) {
                c[cIndex++] = a[aIndex++];
            } else {
                c[cIndex++] = b[bIndex++];
            }
        }

        while (aIndex < a.length - 1) {
            c[cIndex++] = a[aIndex++];
        }

        while (bIndex < b.length - 1) {
            c[cIndex++] = b[bIndex++];
        }

    }
```

## 1. 归并排序


# 二. 希尔排序

希尔排序对于中等大小规模的数组排序表现良好。

虽然它不像快速排序或其他复杂度为O(N*㏒N)的排序算法那么快，但是比选择排序和插入排序这种O(N²)的排序算法还是要快很多

关键希尔算法代码既短又简单，

并且在最坏情况下和平均情况下执行的效率并没有差很多，

而快速排序如果没有采取预防错误，最坏的情况下执行效率会非常差。

所以有专家建议，在排序工作开始时可以采用希尔排序，若在实际中证明它不够快，再采用诸如快排这样更高级的排序算法。

## 1. 插入排序的问题
由于希尔排序是基于插入排序的，所以我们有必要回顾下[插入排序](data_structures_01.md#插入排序)

复制的次数太多，平均需要移动N/2个元素


## 2. n-增量排序
由于希尔排序是基于插入排序的，所以我们有必要回顾下[插入排序](data_structures_01.md#插入排序)

复制的次数太多，平均需要移动N/2个元素

希尔排序通过加大插入排序中元素的间隔，并在这些有间隔的元素中进行插入排序，从而使数据能大幅度的移动。
![希尔排序](../../Resource/data_structures_07_1.png)

* 当对0，4，8完成排序后，算法右移一位，对1，5，9排序
* 持续进行，直到所有数据都完成4-增量排序
* 当完成4-增量排序后，可进行普通的插入排序，即1-增量排序

### 2.1 如何减少间隔

上面介绍了以4为初始间隔对包含10个数据项进行排序的情况。

对于不同数量的数据项，间隔应该是动态变化的，开始间隔很多，然后不断缩小，直至为1(即插入排序)。

举例：包含有1000个数据项的数组，可能一开始先以164作为增量，然后121，然后40，然后13，然后4，最后以1为增量进行希尔排序，用来形成间隔的数列称之为`间隔序列`

`间隔序列`由Knuth提出，此数列以逆向的形式从1开始，通过递归表达式`h=3*h+1`,来产生


如何使用间隔序列呢？

一直调用表达式，直到h值大于数组长度为止，则h值作为起始间隔，当然也可以用`h=(h-1)/3`倒推
# 三. 划分

# 四. 快速排序

# 五. 基数排序


