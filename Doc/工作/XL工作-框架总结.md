# 一. ORM
ORM应该是系统走向成熟的第一步，也是评估一个单体应用是否方便的一个重要考量



这里有一个不断变化或者说是争论的观点：ORM要不要支持多数据源？

1. 早期大都是系统都是以改造或集成类项目为主，当从 一个系统迁移到另一个系统时，支持多数据源还是比较方便的。所以这个阶段大都数的ORM是支持多数据源的。

2. 之后大都数公司或团队，随着技术的发展，大都数不限于做集成改造类项目，大都数都具备了单独开发产品的能力，做产品时，对技术选择有了更大的话语权，这时发现更换数据源会涉及到系统的很多方便改造。所以都倾向于数据源保持不变，所以ORM的多数据源变成可选了。

3. 但是随着devops的发展，开发测试一体化又要求能够方便独立的搭建一个系统。测试，开发，演示的系统数据源都是不一样的。所以


XL这里的问题是：**虽然框架从底层支持了多数据源，但是并没有将该特性广泛应用。**

具体就是上面的第三点没有实现,理想的开发环境应该是支持数据源无缝切换的：

1. 不同类型数据库

    开发时使用`sqllite`/`H2`等内存数据库，正式部署时采用`mysql`/`oracle`

2. 同类型数据库，不同源

    测试时使用xltest，正式用xl

# 二. 定时任务

在系统发展演化的过程中，经历了两个阶段：
1. 以winform为主体的自动任务
2. 以控制台为主体的智能任务


# 1. 自动任务

作为系统的第一版任务，其实是有不少亮点的。

从架构的角度来看，甚至比后续的智能任务更加合理。


最核心的几个对象`TaskConfig`,`Task`,`TaskPeroid`

`Task`表示一个具体的任务基类，子类负责集成该类，实现`Run`方法，`Run`方法里面则是具体的业务逻辑。

`TaskConfig`则表示一个任务的配置信息，根据配置信息可以创建一个`Task`,设置/获取一些参数配置：运行周期，最大执行时间，重试次数

`TaskPeriod` 则表示任务运行周期基类，子类负责具体的任务调度时间。内置了分钟、小时、日、月、年。

**这里我学到的**：
1. 如何通过将一个定时任务中重要的几个概念抽象成上述3个对象，抽象是软件工程中非常重要的概念。
2. 任务运行时，如果暂停、停止，即如何中断一个正在运行中的任务

    大都数静态语言的线程机制都是基于协作式的，一个线程无法主动停止自己。

3. 如何通过模板模式搭建任务框架

    主要参考`Task`的`Start`实现

4. 如何实现周期性间隔任务

    本质上是采用`System.Threading.Timer`定时执行，并在每次执行后，生成下次执行的时间