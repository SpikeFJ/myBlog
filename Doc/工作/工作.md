
# 项目简述
该项目主要功能是采集/上报电力数据进行统计分析。

电力数据通过主动采集和主动上报两个方式获取。

整个项目采用插件式框架开发，对于熟悉了满大街的MVC，SSH等框架的我来说，一开始接触插件式开发时确实很新鲜。

在我看来插件式开发的核心理念就是模块划分、接口定义、功能聚合，对应到系统ApplicationClass就是启动时加载所有dll，按接口组织成对应结构。


## 历史背景

该项目原本是用于供电局内部的采集系统，负责采集电力数据并分析统计。由于不同厂家的设备规约都不尽相同，所以框架一开始就采用了插件模式，每个规约、功能、界面都由一个个插件组成。

后来项目转型，目标对象变成了普通企业和环保局。一个项目由2B转为2C,变动还是很大的。底层架构的变动如下
*  web系统

    原本供电局内部一个系统负责档案录入，数据展示。拆分变为两个web：后台管理web仍旧负责档案录入，数据展示。另外添加前台展示界面，目的是提供更好的用户体验并针对不同用户提供不同的分析统计报表，与后台web职责分离，具备独立的权限分配。

* 前置机

    对于一般通用系统，可能不是很了解前置机这个概念。、在采集系统中，前置机负责两部分功能：
    1. 负责现场终端设备的连接、规约解析
    2. 相应后端应用/用户的请求(数据转发、控制)

    前置机的由原来的Net程序变更为C++，变换语言与技术无关。

# 亮点
* 系统系统时加载所有dll，获取了所有运行时信息
* 业务的抽象：设备、单元等
* 插件的抽象：设备、规约、通道、驱动、单元、功能等插件
* 对象搜索器、筛选器：某种形式的ORM
* 自动任务：如何采用简单易懂的方式实现调度
* 智能任务：如何调度、重试策略、补采策略
* ListItem：结合自定义报表

# 团队现状
目前我们整个平台分为前端、后台、大数据3个部门。

* 前端负责展示相关分析、统计、明细等报表给最终用户。
* 后台负责档案录入、原始数据展示；定时采集任务；前置机
* 大数据部门负责数据采集、上报处理

由于我负责后台项目，所以重点说下后台，后台分为web、前置机、任务调度及消息队列处理、websocket推送等。

* web

  问题主要是前后端没有分离

* 前置机
   
   没有方便的对外暴露相应的接口

* 任务调度

    调度没有和业务解耦

* 其他

# 问题
* 代码管理

    采用git管理，git在分支管理上可以满足现场提交了但不要发布，bug修改优先发布等需求

* 单元测试

    自动化测试的基础

* 数据表

    表结构的确定、主键的选择等<br>
    表名通过适当的前缀区分不同的模块<br>
    每张表都应该具有一些基本字段：创建时间、更新时间、操作人(和具体业务相关，忽略)、版本号<br>
    禁止物理删除，通过状态区分是否已删除。

* ORM与缓存

    禁止手工写sql，在分库分表、引入数据库中间件后，应该避免复杂sql；
    如果没有复杂sql，那简单sql应该全部可以通过orm工具生成，简单的sql配合多级缓存可以保证sql操作性能。

* 事务

    如果不需要事务，在基本档案上添加表示状态的字段，通过状态来识别档案的完整性。大量表报需要修改

* 服务、主备

    每个单独的启动项目都应该能作为服务运行，所以服务的安装应该是通用的，与具体项目无关的。
    同理、主备/多主也应该作为通过的组件调用。

* 前后端

    后端只提供具体的API，不管后台维护还是前台展示统一通过API操作、获取，

* 账号权限

    后台账号的权限应该聚焦于能看到那些操作对象/资源，至于对象/资源的属性不应该判断。<br><br>
    整个系统一套账号，丰富账号表。
    功能是合并成一个还是拆分多个？如果权限能细分到按钮级别。那还是合并的好。<br><br>
    但是如果只是api获取的话，操作资源就是API了

* 对象

    每一个对象需要有自己的配置和全局的配置

* 日志

    日志需要划分合理，是保存到数据库还是TXT文本；

* 任务

    和具体的业务对象耦合了，任务应该只管调度这一个核心功能
    
* 文档自动生成。导出、导入


# 思考
* 如何判断软件好坏，我的理解: **逻辑正确>可读性>可扩展性**，在软件开发中比较重要的几点

    * 微服务
     广义上的微服务，就是模块的划分、管理，实际上还是分层、解耦、聚合
     * 消息队列
     解耦的利器，但是需要一开始就定义好消息交互的格式
     * 任务调度
     每个系统都应该具备定时执行的框架


* 关于框架  

作为统一平台，在运行时候加载所有程序集(dll/jar)包<br>
通过接口、注解等方法将所有数据加载到内存中

以前我一直很疑惑为什么会采用这种方式开发，
现在发现这是主流平台框架常用的方式，不管application还是spring本质是一样的。


平台区分技术框架和业务框架 技术框架与业务无关，提供基本权限、缓存、数据库操作、api调用以及与第三方框架集成的能力。<br><br>
业务框架则类似于领域建模，针对不同领域的业务提取公用逻辑、业务操作、流程。

作为技术人、需要把握好技术方向感。
需要具备分辨好的架构与坏的架构的能力。
每一次技术选择都需要慎重。

近几个月也接触了多个java项目组的开发源码。发现和2009的代码结果没什么区别，只是多了mq、redis等交互。
所以我最近的感想就是：spring框架只是保证一些功能的顺利交互，它能够保证项目的下限不会很低，但是上限也不会很高。
当我看到项目中充斥着dao、service的时候，我就会疑惑这种代码真的具有可读性吗，根本无法体现业务场景。

真正优秀的架构应该是20%的技术框架，80%的业务框架，也就是领域框架，针对领域编程才能真正的搭建合理的框架。
***




技术
* 中小型应用需要的是快速开发，ORM必须
* 大型应用三个核心组件：RPC、Redis、MQ
- 日志是一个必须考虑的组件，结合ELK做数据分析
- 通讯组件是大规模RPC的基础，netty是dubbo、RocketMq等框架的核心通讯层
- websocket和tcp通讯的区别：websocket在握手阶段还是采用的Http协议，在通讯阶段采用的tcp通讯；
tcp相较于websocket更偏向底层，websocket的onopen,onclose都是在tcp之上的封装
- mq(消息队列)的订阅功能，是socket搭配完整的通讯协议实现
- 文件存储-fastDFS

- IOC,AOP等功能都是dll/jar加载后的后续动作
业务
- 人员管理系统是基础
- 配置信息zookeeper
- 权限必须搭建

- SocketAsyncEventArgs
- 极客时间，编译原理，youtube大佬
- 沈询关于分布式数据理论



### 技术

1. 加载dll的帮助类
2. 元数据解析
3. 接口的定义于第三方的融合


* 消息队列应该有更广阔的应用

* TCP/UDP底层服务框架
    * 负责底层TCP、UDP连接。
    * 前置端口+后置端口。
    * 解决沾包、拆包。分包间隔，通讯超时。
    * 按不同格式的规约解析包(此处是否要依赖具体应用层)

    > 参考Netty，引入codec框架，codec框架是否需要和具体的规约挂钩？
     如果不挂钩，如何解析不同的规约帧
    
    * 可以基于此客户端编写各种开源数据库驱动
    * 1）推模式：把所有事件、数据写入Mq，供第三方模块写
      2）拉模式：对外暴露接口，第三方模块主动调用

* 后台高级服务
    * 客户端连接、登陆、通讯时候预留钩子，最好是写入Mq，以便多种客户端/第三方接口调用

    * 服务提供两中方式：实时通知(Mq)和restfulApi。
    * 对外服务:当前有多少连接
              tps
              每个连接的详细信息
              发送(阻塞/非阻塞) 
* 

* ORM可视化工具
* 配置表/配置组
    1. codeName，(主键，通过改字段获取配置信息)
    2. 中文名称
    3. 描述
    4. 排序字段
    5. 所属配置组Id
    6. 创建时间
    7. 更新时间
    8. 创建者Id

## 任务调度
1. 调度模块负责在指定的任务周期内写入MQ
2. 执行模块由具体业务子模块提供，执行完成后，通知调度模块

<P>
作为服务端，应该对任何第三方调用保持不信任。<br>
作为客户端，则应该对服务端百分百信任(在已达成一致的协议基础上)，如果不信任服务端，会导致很多无效动作，备份、准确性处理等。
</P>



## 关于规则引擎

什么是规则：
1.当事件(上报数据、上报事件、账号操作、上报异常)产生时，判断是否满足XX条件，满足则执行某个动作
2.事件需要主体对象吗？XX设备上报数据？
3.条件可以组合
4.动作如何定义？动作一定有一个施加的目标对象？device、account？或者只是打印一句话？
  动作联动不需要？动作可以是产生某个事件，递归

eg:当1#设备电压数据>128时，发送异常短信给负责人XX
eg:当系统整体电量>10万kWh时，在用户弹窗祝贺
eg:当2#设备掉线时，发送异常短信给负责人XX

数据规则：
    触发条件：数据产生时
    判断条件：XX对象的XX数据
    执行动作：

档案规则：
    触发条件：新建档案时
    判断条件：XX区域/XX时间/XX账号

方案1：
//1.首先检测到一个事件(规则的启动入口，通过mq订阅或者有一个路由规则)
//2.有一系列条件判断
//3.判断为真，执行一个动作，动作可以继续产生事件
Rule
{
    bool start;//此处开启mq监听
    public Condition contion;
    public Action action;
    void triggle<T> where T:EventData(T event);
}

Condition有各种子类。不同的子类对应不同的EventData
```
1.当事件(上报数据、上报事件、账号操作、上报异常)产生时，执行某个动作
	可以有某个对象，如xx设备上报数据时，也可以没有对象：当系统整体电量<100kwh时，告警
	
	当满足某个条件时，执行某个动作
	
2.如何定义动作，
	动作:开/关灯、给账号发送短信、
	动作一定有一个施加的目标对象？device、account？或者只是打印一句话
	可能是一批目标，批量停电、批量发短信

3.后续动作



	
以上可以抽象出规则类
Rule
{
	Condition condition;//判断的依据
	boolean event(EventData data);//事件的入口
	Action action;//执行的动作
}
```

## 接口谁来定义

接口需要提前设计，前后端分离就是面向api开发
api不是由前端或后端某一方决定或主导的，而是需要一个前后端都熟悉的人，就是架构师


原来放在后端的，逐步移至前端，前端承担了很大一部分功能，如路由、权限

如果没有一个能够全盘考虑的架构师，更倾向于前端决定前后端的交互api
对于用户来说，界面就是一切，界面是他使用的入口

前端先开发出界面原型后，在确定界面风格、布局、跳转、交互的过程中，自然会形成需要获取数据的接口，这些接口是前端真实需要的
在没有前端，或者后端开发根本不考虑前端的情况下，后端产生的接口是想象中前端需要的接口，而且完全站在后端的技术角度。
前端调用会很别扭（简单说命名），甚至是完全不能满足前端需要的。