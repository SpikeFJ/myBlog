# 哈希
优点：插入和删除都是O(1)<br>
缺点:基于数组，难于扩展，无序。

# 一. 哈希化简介
首先思考下如何将给定的一个元素转换成数组下标？

在哈希表中是通过`哈希函数`来转换的，其实对于特定的关键字并不需要哈希函数。
## 1. 简单的员工存储

如现在要写一个程序，读取公司员工，公司总共1000个员工，每个员工1K存储空间，整个公司消耗1M。

可以设计每个员工一个特定的编码，从1到1000，该编码就作为员工记录的关键字。

所以在着这种情况下根本不需要哈希函数，直接分配1000个空间的数组，用员工编码作为数组下标即可存储读取相关记录。

## 2. 字典查找
上述员工系统，由于有编码这个特殊的关键字，所以不需要设计什么哈希函数，

现在考虑下如果想设计一个字典程序，输入一个单词，查找对应的记录，该如何设计呢？

由于单词并没有特殊的关键字可供使用，所以必须采用某种手段将`单词转化成数组下标值`

由于单词是由26个字母组成的，可以针对26个字母自定义字母和数字的映射，如果不想自己定义映射也可以直接采用`ASCII`编码来作为字母和数字映射的工具，如a->97,b->98,

那么我们可以采取以下几种方式生成关键字：

1) 数字相加
> 如cats，c=1,a=2,t=3,s=4---->组合后的值=10，那么cats就存储在下标为10的位置

缺点是：
```
    1) 重复下标太多，如cats 和 satc 。
    2) 如果z=26，zzzzzzzzzzzzzzzzzzz=26*n,单单这一个单词就会大量占用存储空间
```
2) 幂的连乘

    既然数字相加由重复下标，我们先解决重复下标的问题，可以考虑将位置信息带入到下标中，如cat和tac，其中cat第一位是c，而tac第一位是t，所以有了以下解决方案(选择27幂)：
```
cats= 1*27³+2*27²+3*27¹
```

虽然该方法解决了重复下标的问题，即为每一个单词生成了一个唯一的下标，但并没有解决反而扩大了存储空间过大的问题

## 3. 哈希化

所以我们引入哈希化，它的作用就是将一批巨大的整数范围压缩到可以接受的数组范围中。

考虑下如果将0-199的数字压缩到0-9之间，该如何操作呢，其实很简单直接对数字10`取模`即可
> a%10

但是取模会造成冲突，这样又回到了原来的老问题上了？

## 4. 解决冲突

### 4.1. 开放地址法

申请数组存储空间时，预先申请双倍的空间，然后在多余的单元中寻找空白单元。
在找空白单元时，又有三种方法分别是：`线性探测`、`二次探测`和`再哈希法`。

  4.1.1. 线性探测

    插入：
        
        如果1是你计算出来的下标，查看该下标已有数据，则继续查询2，3，5依次类推，直到找到为空的下标。

    查找：
        根据关键字计算出下标，如果下标值不是查找的值，则表明发生了冲突，需要依次往后查找，直到找到正确的关键字`或`遇到一个空位，空位代表失败。

  4.1.2. 二次探测
  
    线性探测时容易引发元素聚集，这样会导致效率下降。-->x,x+1,x+2,x+3
    
    二次探测的解决之道就是：当检测到冲突时，采用x->x+1,x+4,x+9,x+16来避免聚集

    其实二次探测也会产生聚集，只不过不是大规模的聚集，而是相隔比较远的聚集。

  4.1.3. 再哈希法
  
    二次探测聚集的原因在于步长是确定的，如1，4，9，16

    再哈希化，采用不同的关键字使用不同的探测函数生成不同的步长，可以解决聚集的问题

### 4.2. 链地址法

    和开放地址法，在检测到冲突时再去找一个空位的思想不同，

    链地址法在检测到冲突时，就是在冲突的这个位置上生成一个链表，用链表来存储冲突的元素。
    
    具体可以参考下面的HashMap实现。



## 5. 哈希函数

哈希函数的选择要点是：

**1.去掉关键字中的无用信息**

**2.尽量使用所有的数据**


