本篇主要分析下`xxl-job`的原理及使用，具体环境搭建及运行启动省略。

---

xxl-job：

1. 类`XxlJobInfo`代表一个可执行的任务，对应表`xxl_job_info`。该表上的`job_group`代表对应的执行器，即该任务交由哪个执行器执行
2. 类`XxlJobGroup`表示一个执行器。




# 调度
1. 如何知道有多少个可执行节点

    执行器启动时会主动通过rpc通知调度中心
    
2. 如何调度

# 执行
1. 执行结果如何通知


首先启动调度中心，可以看到控制台有如下输出
```
10:54:39.116 logback [main] INFO  c.x.j.a.c.scheduler.XxlJobScheduler - >>>>>>>>> init xxl-job admin success.
```

全文搜索`init xxl-job admin success`字眼，发现`XxlJobScheduler`的`init`方法中打印该字眼。打上断点调试。

---


`XxlJobAdminConfig`的`afterPropertiesSet` 作为执行入口。这应该是`spring`的执行机制，暂时记录下疑问，后续学习spring时再回顾，在`afterPropertiesSet`中，新建一个`XxlJobScheduler`对象，并调用其`init`方法

    1.为什么初始化会进入XxlJobAdminConfig的afterPropertiesSet方法
    2.为什么 XxlJobAdminConfig 继承了InitializingBean ，并且添加了Component

下面是`XxlJobScheduler`的`init`方法，针对`init`中的方法逐个研究
```java
public void init() throws Exception {
    // init i18n
    initI18n();

    // admin registry monitor run
    JobRegistryMonitorHelper.getInstance().start();

    // admin monitor run
    JobFailMonitorHelper.getInstance().start();

    // admin trigger pool start
    JobTriggerPoolHelper.toStart();

    // admin log report start
    JobLogReportHelper.getInstance().start();

    // start-schedule
    JobScheduleHelper.getInstance().start();

    logger.info(">>>>>>>>> init xxl-job admin success.");
}
```
---

# 1. JobRegistryMonitorHelper
`JobRegistryMonitorHelper`是一个后台轮询线程，一直在后台执行下列逻辑：

* 1.1. 找出`xxl_job_group`中所有执行器类型是自动注册的记录（执行器表？取名有点随意），如果无记录则返回。

```sql
SELECT <include refid="Base_Column_List" />
FROM xxl_job_group AS t
WHERE t.address_type = #{addressType}
ORDER BY t.order ASC
```
* 1.2. 删除所有已死亡的()`xxl_job_registry`记录。判断依据:最后一次更新时间距离当前时间相差90s，这里使用了date_add函数。
```sql
-- id="findDead":找到已死亡的记录
SELECT t.id
FROM xxl_job_registry AS t
WHERE t.update_time <![CDATA[ < ]]> DATE_ADD(#{nowTime},INTERVAL -#{timeout} SECOND)
-- id="removeDead":删除已死亡的记录
DELETE FROM xxl_job_registry
WHERE id in
<foreach collection="ids" item="item" open="(" close=")" separator="," >
    #{item}
</foreach>
```

* 1.3. 找到存活的执行器，针对所有`registry_group`等于`EXECUTOR`的记录，将`registry_key`，`registry_value`组织成`key:appName,value:List<registryList>`的形式
```sql
-- id="findAll":找到所有的记录
SELECT <include refid="Base_Column_List" />
FROM xxl_job_registry AS t
WHERE t.update_time <![CDATA[ > ]]> DATE_ADD(#{nowTime},INTERVAL -#{timeout} SECOND)
```

* 1.4. 遍历步骤1中的`groupList`,将`group`对象中的`setAddressList`更新成步骤3中的`key-value`中的`value`值。
```sql
-- id="findAll":找到所有的记录
SELECT <include refid="Base_Column_List" />
FROM xxl_job_registry AS t
WHERE t.update_time <![CDATA[ > ]]> DATE_ADD(#{nowTime},INTERVAL -#{timeout} SECOND)
```

**总结：`JobRegistryMonitorHelper`做了两件事**
1. 删除`xxl_job_registry`中无效的记录
2. 更新`xxl_job_group`中的`address_list`,其中`address_list`来自于`xxl_job_registry`的`registry_value`


# 2. JobFailMonitorHelper

* 2.1. 查找日志表中所有非成功的且告警状态为默认的前1000条记录
```sql
SELECT id FROM `xxl_job_log`
WHERE !(
    (trigger_code in (0, 200) and handle_code = 0)
    OR
    (handle_code = 200)
)
AND `alarm_status` = 0
ORDER BY id ASC
LIMIT #{pagesize}
```
遍历步骤1中的所有记录并执行后续步骤：

* 2.2. 将告警状态更新为-1，更新失败则退出。
```sql
SELECT id FROM `xxl_job_log`
WHERE !(
    (trigger_code in (0, 200) and handle_code = 0)
    OR
    (handle_code = 200)
)
AND `alarm_status` = 0
ORDER BY id ASC
LIMIT #{pagesize}
```

* 2.3. 根据日志id找到`jobinfo`
```sql
SELECT <include refid="Base_Column_List" />
FROM xxl_job_info AS t
WHERE t.id = #{id}
```

* 2.4. 如果日志失败重试次数>0,则调用`JobTriggerPoolHelper.addTrigger`
* 2.5. 如果`jobinfo`的告警邮箱不为空，则调用job.alarm
* 2.6. 更新告警状态

**总结：`JobFailMonitorHelper`执行以下流程**
1. 更新告警状态为-1（用于锁定log中的记录）
2. 根据重试次数，添加触发器
3. 判断是否有邮箱，调用告警
4. 更新告警状态


# 3. JobTriggerPoolHelper
* 3.1  `JobTriggerPoolHelper`的`start`方法，新建两个线程池:`fastTriggerPool`和`slowTriggerPool`

# 4. JobLogReportHelper

* 4.1. 对最近三天的日志记录进行更新
from：每天的零点，to:每天的23:59：59
```sql
SELECT
    COUNT(handle_code) triggerDayCount,
    SUM(CASE WHEN (trigger_code in (0, 200) and handle_code = 0) then 1 else 0 end) as triggerDayCountRunning,
    SUM(CASE WHEN handle_code = 200 then 1 else 0 end) as triggerDayCountSuc
FROM xxl_job_log
WHERE trigger_time BETWEEN #{from} and #{to}
```

# 5. JobScheduleHelper

* 5.1. 休眠XX毫秒
* 5.2. 获取数据库锁
```sql
select * from xxl_job_lock where lock_name = 'schedule_lock' for update
```
* 5.3. 查找需要执行的任务,下次调度时间<(now+5秒)的记录。
```sql
SELECT <include refid="Base_Column_List" />
FROM xxl_job_info AS t
WHERE t.trigger_status = 1
    and t.trigger_next_time <![CDATA[ <= ]]> #{maxNextTime}
ORDER BY id ASC
LIMIT #{pagesize}
```
循环需要执行的任务，执行以下逻辑：
1) >5秒：认为已经超时，计算下一次触发时间。
2) <5秒：触发时间已满足，利用JobTriggerPoolHelper这个类进行任务调度，判断下一次执行时间如果在5秒内，进行此任务数据的缓存，处理逻辑与第三个分支一样。